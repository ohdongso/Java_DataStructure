/*
●큐의 구조
- 큐(Queue)는 스택과 마찬가지로 삽입과 삭제의 위치와 방법이 제한되어 있는 유한 순서 리스트지만,
  스택과 달리 리스트의 한쪽 끝에서는 삽입 작업이 이루어지고 반대쪽 끝에서는 삭제 작업이 이루어져서,
  삽입된 순서대로 삭제되는 선입선출의 구조로 운영된다.
- 큐는 한쪽 끝은 프런트(front)로 정하여 삭제 연산만 수행하도록 하고, 다른 쪽 끝은 리어(rear)로 정하여
  삽입 연산만 수행하도록 제한한다. 큐에서 프런트 원소는 가장 먼저 큐에 들어온 첫 번째 원소이고,
  리어 원소는 큐에 가장 늦게 들어온 마지막 원소다.
- 큐의 리어(삽입되는 곳)에서 이루어지는 삽입 연산을 인큐(enQueue)라고 하고, 프런트에서 이루어지는 
  삭제 연산을 디큐(deQueue)라고 한다.
●큐의 추상 자료형
(1), 공백 큐 생성:createQueue(); ==> front와 rear가 같은 위치에 있다.
(2), 원소 A 삽입:enQueue(Q,A);
(3), 원소 B 삽입:enQueue(Q,B);
(4), 원소 삭제:deQueue(Q);
(5), 원소 C 삽입:enQueue(Q,C);
(6), 원소 삭제:deQueue(Q);
(7), 원소 삭제:deQueue(Q); ==> front와 rear가 같아 진다.
==> 초기
●순차 자료구조 방식을 이용한 큐의 구현
- 선형 큐:1차원 배열을 사용하여 순차 자료구조 방식으로 큐를 구현해보자. 이때 배열의 크기는 큐의 크기, 
  즉 큐에 저장할 수 있는 최대 원소의 개수가 된다. 그리고 배열에 저장된 원소 중에서 첫 번째 원소의 인덱스를 저장할 front 변수와
  저장된 마지막 원소의 인덱스를 저장할 rear변수를 사용한다. 초기 공백 큐의 상태는 front 변수와 rear 변수의 값을 -1로 설정한다.
	- 큐에 최대로 저장할 수 있는 원소 개수를 배열을 크기로 하는 1차원 배열을 선언한다. 새로 생성하여 저장된 원소가 없는
  	공백 큐이므로 front와 rear -1로 초기화한다.
	- 큐가 공백인 경우는 createQueue() 연산으로 공백 큐를 생성하여 front==-1, rear=-1인 경우와
  	마지막에 삽입한 rear의 원소를 삭제하여 front가 rear의 위치에 있는 경우가 있다.
  	이때 front와 rear는 같은 값을 갖게 되므로 조건문 if(front=rear)의 결과 값이 참(true)이 된다.
  	큐가 포화 상태인 경우는 배열의 마지막 인덱스까지 원소가 저장된 경우므로 큐에 저장된 마지막 원소의 인덱스, 즉
  	rear의 값이 배열의 마지막 인덱스(n-1)인가를 검사한다.
	- 포화 상태가 아닌 큐에 원소를 삽입하려면 배열에 저장되어 있는 마지막 원소의 다음 자리에 삽입해야 하므로
  	마지막 원소의 인덱스를 저장한 rear의 값을 하나 증가시켜 삽입할 자리를 준비하고, 그 인덱스에 해당하는 배열 원소
  	Q[rear]에 item을 저장한다.
	- 공백 상태가 아닌 큐에서 원소의 삭제는 언제나 큐에 저장된 원소 중에서 가장 앞에 있는 원소, 즉 가장 먼저 큐에 들어와
  	있는 원소를 가장 먼저 삭제해야 한다. 그러기 위해서 front의 위치를 한 자리 뒤로 조정하여 큐에 남아있는 첫 번째 원소의
  	위치로 이동하여 삭제할 자리를 준비하고, 그 자리의 원소를 삭제하여 반환한다. delete() 연산은 front의 원소를 삭제하는
  	연산이고, deQueue() 연산은 front의 원소를 삭제하고 삭제한 원소를 반환하는 연산이다.
	- 큐에서의 검색은 큐에 있는 원소 중에서 가장 먼저 들어와 있는 원소, 즉 Q[front+1]에 있는 원소를 검색하여 반환하는 연산이다.
- 원형 큐:1차원 배열을 사용한 순차 자료구조 방식에는 큐가 포화 상태가 아닐 경우에만 삽입 연산을 수행하도록 정의되어 있다.
	포화 상태를 확인하기 위해서 큐의 rear가 배열의 마지막 위치에 있기 때문에 앞에 빈자리가 있는데도 포화 상태로 인식하고 삽입 연산을 수행하지 않는다.
	- 이런 경우에는 큐의 빈자리를 사용하려면 저장되어 있는 원소를 배열의 앞부분으로 이동시켜서 위치를 조정해줘야 한다.
	그러나 이와 같은 이동 작업은 연산이 복잡하여 큐의 효율성을 떨어뜨린다.
	- 이러한 선형 큐의 문제를 해결하기 위해 원형 큐(Circular Queue)를 사용한다. 원형 큐는 선형 큐와 마찬가지로 1차원 배열을 사용하는데,
	논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 생각하는 것이다.
	- 원형 큐에서는 초기 공백 상태일 때 front와 rear의 값이 0이 되고, 공백 상태와 포화 상태를 쉽게 구분하기 위해서 자리 하나를 항상 비워둔다.
	원형 큐에서의 공백 상태 조건은 front=rear가 된다. rear는 앞으로 이동하면서 원소를 삽입하고 front는 rear가 이동한 방향으로 따라가면서 원소를 삭제한다.
    원형 큐에서의 배열의 인덱스가 n-1 다음에 다시 0이 되어야 하므로 사용할 다음 인덱스를 정하기 위해서 나머지 연산자 mod를 사용한다.
- 원형 큐 알고리즘
	- 초기 공백 원형 큐의 생성 알고리즘:원형 큐 역시 선형 큐와 마찬가지로 1차원 배열을 사용한다.
	새로 생성한 공백 원형 큐는 front와 rear의 초기값으로 0을 설정한다.
	- 원형 큐의 공백 상태 검사 알고리즘과 포화 상태 검사 알고리즘:원형 큐에서 공백 상태가 되는 경우는 createQueue() 연산을
	수행하여 공백 원형 큐를 생성한(front=rear=0) 경우와 마지막에 삽입한 rear의 원소를 삭제하여 front가 rear의
	위치에 있는 경우가 있다. 두 가지 경우의 공백 상태에서는 front와 rear가 항상 같은 위치에 있게 되어 front=rear 상태가 된다.
	rear가 원형 큐를 한바퀴 돌면서 원소를 삽입하여 큐를 모두 채우면 rear의 다음 위치(rear+1) mod n)는 현재의 front 위치가 되어
	더 이상 원소를 삽입할 수 없는 포화 상태가 된다.
	- 원형 큐의 삽입 알고리즘:원형 큐의 현재 상태가 포화 상태가 아닌 경우에만 삽입 연산을 수행한다. 삽입 연산은 먼저
	1, rear의 값을 조정하여 삽입할 자리를 준비하고
	2, 준비한 자리 cQ[rear]에 원소 item을 삽입한다. 원형 큐에서 삽입할 자리를 정하기 위해서 나머지 연산자 mod를 사용한다.
	크기가 4인 원형 큐에서 현재 rear의 위치가 2라면 (2+1) mod 4 = 3이 되어 삽입할 다음 위치는 cQ[3]이 되고, 
	현재 rear의 위치가 3이라면(3+1) mod 4 = 0이 되어 삽입할 다음 위치는 cQ[0]이 된다.
	- 원형 큐의 삭제 알고리즘:현재 원형 큐의 상태가 공백 상태가 아닌 경우에만 삭제 연산을 수행한다. 삭제 연산은 먼저
	(1), front의 값을 조정하여 삭제할 자리를 준비하고
	(2), 준비한 자리에 있는 원소cQ[front]를 삭제하여 반환한다. 원형 큐에서 삭제할 위치를 정하기 위해서 나머지 연산자 mod를 사용한다.
	크기가 4인 원형 큐에서의 연산 과정을 살펴보자.
	(1), createQueue(); ==> 여기서부터


*/