/*
●스택
- 스택(stack)이란 쌓아 올린다는 의미다. 따라서 스택 자료구조라는 것은 접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 형태의 구조를 말한다.
  스택의 형태는 뷔폐식당의 쌓인 접시, 책상 위에 쌓아 둔 책, 안하고 밀려서 쌓인 레포트 등 주변에서 흔히 볼 수 있다.  
  스택은 같은 구조와 크기의 자료를 top이라고 정한 한 곳으로만 쌓을 수 있고, top으로만 접근하도록 제한하여 만든 자료구조다.
- 스택에서는 top을 통해서 들어온 자료가 일정한 방향으로 차곡차곡 쌓인다. 삽입되는 새자료는 top이 가리키고 있는 자료의 위에 쌓인다.
  이때 새로 삽입된 자료는 스택의 마지막 자료가 되고, top이 이 자료를 가리키게 된다. 스택에서 자료를 삭제할 때도 top을 통해서
  만 가능하기 때문에 top이 가리키고 있는 스택의 마지막 자료만 삭제할 수 있다. 따라서 스택은 시간순서에 따라 자료가 쌓이고, 삭제할 때는
  가장 마지막에 삽입된 자료가 가장 먼저 삭제되는 후입선출(Lifo, Last-In-First-Out)의 구조를 갖는다.
- 스택에서 top을 통한 삽입 연산을 push, top을 통한 삭제 연산을 pop이라고 한다.
  ● 스택 S에 자료 x를 삽입하는 push() 알고리즘을 정의하면 다음과 같다.
  1-1, 스택 S에서 top이 마지막 자료를 가리키고 있으므로 그 위에 자료를 삽입하려면 먼저 top의 위치를 하나 증가시킨다.
  이때 top의 위치가 스택의 크기(stack_SIZE)보다 크다면 오버플로우(overflow) 상태가 되므로 삽입 연산을 수행하지 못하고 연산이 종료된다. (top <- top+1;)
  1-2, 오버플로우 상태가 아니라면 스택의 top이 가리키는 위치에 x를 삽입한다. ==> S(top)
  ● 다음은 스택 S에서 자료를 삭제하는 pop() 알고리즘이다.
  스택에서의 삭제 연산은 스택의 마지막 자료 즉, top이 가리키고 있는 자료를 스택에서 삭제하고 삭제한 자료를 반환하는 것이다.
  그런데 만약 top의 값이 0인 공백 스택이라면 삭제할 자료가 없으므로 삭제 연산을 수행하지 못한다.
  2-1, 스택이 공백 스택이 아니라면 top이 가리키는 원소를 먼저 반환한다. ==> return S(top)
  2-2, 스택의 마지막 자료가 삭제되면 top의위치는 그 아래의 자료가 되므로 top의 위치를 하나 감소시킨다. ==> top <- top-1
  
●스택의 구현
  1, 순차 자료구조방식을 이용한 스택의 구현
  순차 자료구조인 1차원 배열을 이용하여 스택을 구현할 수 있다. 1차원 배열 stack[n]을 사용할 때 n은 배열 크기로서 
  배열원소의 개수를 나타내는데, 이것이 스택의 크기가 된다. 스택에 원소가 쌓이는 순서는 배열의 인덱스(index)로 표현한다.
  따라서 스택의 첫 번째 원소는 stack[0]에 저장하고, 스택의 두 번째 원소는 stack[1]에 저장하고, 
  스택의 i번째 원소는 stack[i-1]에 저장된다.
  
  스택의 top을 표현하기 위해서 배열 stack의 마지막 원소의 인덱스를 변수 top에 저장한다.
  변수 top은 0부터 n-1까지의 인덱스를 저장하므로, 스택이 초기상태(공백스택)일 때 top에는 -1을 저장한다.
  
  크기가 5인 스택을 생성하여 원소 A, B, C를 순서대로 삽입한 후에 원소 하나를 삭제하는 과정을 살펴보자.
  (1), 공백 스택 생성 : Create(stack, 5);
  (2), 원소 A 삽입 : push(stack, A);
  (3), 원소 B 삽입 : push(stack, B);
  (4), 원소 C 삽입 : push(stack, C);
  (5), 원소 삭제 : pop(stack);
  
  2, 연결 자료구조 방식을 이용한 스택의 구현
  순차 자료구조를 이용한 스택은 배열을 사용하여 구현하기는 쉽지만, 물리적으로 크기가 고정된 배열을 사용하기 때문에 스택의 크기를 변경하기가 어렵고,
  메모리의 낭비가 생길 수 있다는 문제가 있다. 이러한 순차 자료구조 방식의 문제는 연결 자료구조 방식을 이용함으로써 해결 할 수 있다.
  
  연결 자료구조 방식의 단순 연결 리스트를 이용하여 스택을 구현하면 스택의 원소는 연결 리스트의 노드가 된다.
  스택에 원소를 삽입할 때마다 연결 리스트에 노드를 하나씩 연결한다. 그리고 스택 원소들 간의 순서는 연결 리스트 노드의 링크를 사용하여 표현한다.
  스택의 top을 표현하기 위해서 참조 변수 top을 사용한다. 
  
  스택의 초기 상태(공백 스택)는 참조변수 top을 null로 설정하여 표현한다. 
  공백 스택을 생성하고, 원소 A, B, C를 순서대로 삽입한 후에 원소 하나를 삭제하는 과정을 살펴보자.
  (1), 공백 스택 생성 : create(stack);
  (2), 원소 A 삽입 : push(stack, A);
  (3), 원소 B 삽입 : push(Stack, B);
  (4), 원소 C 삽입 : push(Stack, C);
  (5), 원소 삭제 : pop(stack);
  
●스택의 응용
  1, 역순 문자열 만들기
  스택의 LIFE 성질을 이용하여 문자열에 대한 역순 문자열을 간단히 만들 수 있다. 문자열을 처움부터 순서대로 스택에 삽입(push)한다.
  이제 스택에 있는 원소들을 공백 스택이 될 때까지 삭제하면서 반환된 문자를 나열하면 원래 문자열의 역순 문자열이 된다.  

  2, 시스템 스택
  "프로그램 간의 호출과 복귀"에 따른 수행 순서를 보면, 호출한 순서와 복귀하는 순서는 반대가 되어 
  나중(Last)에 호출된 함수가 가장 먼저(First) 실행을 완료하고 복귀한다.
  따라서 함수의 호출과 복귀 순서는 스택의 LIFO 구조를 응용하여 관리하는데, 이때 사용하는 스택을 시스템 스택(System Stack)이라 한다.
  
  (1), 주 프로그램인 main() 함수 실행 시작
  (2), F_1()함수 호출
  (3), F_1()함수를 실행 중에
  (4), F_2()함수 호출
  (5), F_2()함수를 실행
  (6), F_2()함수 실행을 마치고 호출 위치로 복귀
  (7), F_1()함수로 복귀(복귀주소:b)하여 나머지 부분 실행
  (8), F_1()함수 실행을 마치고 호출 위치로 복귀
  (9), main() 함수로 복귀(복귀주소:a)하여 나머지 부분을 실행하고 종료
  
  위의 프로그램 수행에 따른 시스템 스택의 변화를 살펴보자
  (1), 프로그램이 실행을 시작하여 main() 함수가 실행되면서 main() 함수와 관련된 정보를 스택 프레임에 담아 시스템 스택에 삽입한다.
  ==> push(System_stack, stack_Frame(main));  
  (2), main() 함수 실행 중에 F_1() 함수 호출을 만나면 함수 호출과 복귀에 필요한 정보를 스택 프레임에 담아
  시스템 스택에 삽입한다. 이때 스택 프레임에는 호출된 함수(F_1())의 수행이 끝나고 main() 함수로 복귀할 때 필요한 주소 a가 저장된다.
  ==> push(System_stack, stack_Frame(F_1));  
  (3), 호출된 함수인 F_1() 함수를 실행한다.
  (4), F_1() 함수 실행 중에 F_2() 함수 호출을 만나면 다시 함수 호출과 복귀에 필요한 정보를
  스택 프레임에 담아 시스템 스택에 삽입한다. 이때 스택 프레임에는 F_1() 함수로 복귀할 때 필요한 주소 b가 저장된다.
  ==> push(System_stack, stack_Frame(F_2));
  (5), 호출된 함수인 F_2()함수를 실행한다.
  (6), F_2() 함수 실행이 끝나면 F_2() 함수를 호출했던 예전 위치로 복귀하여 함수(F_1())의 실행을 계속해야 한다.
  그러려면 복귀할 주소 정보가 필요한데, 이런 정보들은 시스템 스택에 있으므로 시스템 스택의 top에 있는 스택 프레임을 pop하여 정보를 확인하고 복귀를 실행한다.
  ==> pop(System_stack);
  (7), F_1() 함수로 복귀하여 F_1() 함수의 나머지 부분을 실행한다.
  (8), F_1() 함수의 실행이 끝나면 이제 F_1() 함수를 호출했던 main() 함수의 예전 위치로 복귀하여 다시 실행을 계속해야 한다.
  그러려면 역시 복귀할 주소 등의 정보가 필요한데, 이런 정보들을 얻기 위해서 시스템 스택의 top에 있는 스택 프레임의 pop하고 복귀를 실행한다.
  ==> pop(System_stack);
  (9), main() 함수로 복귀하여 나머지 부분을 실행한다. 실행이 끝나면 다시 시스템 스택의 top에 있는 스택 프레임을 pop하고 복귀를 실행하는데,
  주 프로그램인 main() 함수는 복귀할 주소를 가지고 있지 않으므로 전체 프로그램의 수행이 완료된다. 정상적인 함수 호출과 복귀가 모두 완료되었으므로
  시스템 스택은 공백 스택이 된다.
  ==> pop(System_stack);
  
  3, 수식의 괄호 검사
  수식은 일반적으로 연산자(operator)와 피연산자(operand)로 구성되어 있으며, 왼쪽에서 오른쪽 순서로 처리한다.
  수식에 사용한 연산자의 우선순위가 다를 경우에는 우선순위가 높은 연산자를 먼저 처리하는데, 괄호를 사용하여 우선순위를 표현하기도 한다.
  이때 괄호는 일반괄호((,))와 중괄호({,}) 또는 대괄호([,])를 사용한다. 괄호는 왼쪽 괄호와 오른쪽 괄호가 반드시 쌍을 이루어야 하며,
  여러 개의 괄호가 중첩된 경우에는 가장 안쪽의 괄호를 먼저 처리한다.
  
  괄호가 포함된 수식에서 괄호의 쌍이 제대로 사용되었는지를 검사하기 위해서 스택을 사용 할 수 있다.
  수식을 읽으면서 왼쪽 괄호를 만나면 스택에 push하고, 오른쪽 괄호를 만나면 괄호면 괄호의 쌍이 맞는 것이고, 수식의 처리가 모두 끝났을 때
  스택이 공백 스택이 되면 왼쪽 괄호와 오른쪽 괄호의 개수가 맞는 것이다.  
  
  {(A+B)-3}*5+[{cos(x+y)+7}-1]*4 ==> 원본
  { (A + B) - 3 } * 5 + [ { cos(x + y) + 7} - 1 ] * 4
  (1), push(stack, '{' )
  (2), push(stack, '(' )  
  (3), pop(stack) ==> '('
  (4), pop(stack) ==> '{'
  (5), push(stack, '[')
  (6), push(stack, '{')
  (7), push(stack, '(')
  (8), pop(stack) ==> '('
  (9), pop(stack) ==> '{'
  (10), pop(stack) ==> '{'
  ==> 각 과정에서 처리할 오른쪽 괄호와 스택에서 pop한 원소가 같은 종류의 괄호이고, 수식 처리가 끝났을 때
  스택이 공백 스택이 되었으므로 위의 수식은 괄호가 올바르게 사용된 수식임을 확인할 수 있다.
  
  4, 수식의 후위 표기법 변환
  연산자와 피연산자로 구성된 수식을 표기하는 방법은 연산자의 위치에 따라 다음의 세 가지 표기법이 있다.
  (1), 전위 표기법(Prefix Notation)
  연산자를 앞에 표기하고 그다음에 피연산자를 표기하는 방법 ex) +AB
  (2), 중위 표기법(Infix Notation)
  연산자를 피연산자의 가운데에 표기하는 방법 ex) A+B
  (3), 후위 표기법(Postfix Notation)
  연산자를 피연산자 뒤에 표기하는 방법 ex) AB+
  
  일반적인 중위 표기법의 수식을 전위 표기법으로 변환하는 예를 살펴보자. 
  수식 A*B-C/D를 다음의 방법을 사용하여 전위 표기법으로 변환해보자.
  (1), 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다.
  (2), 각 연산자를 그에 대응하는 왼쪽 괄호의 앞으로 이동시킨다.
  (3), 괄호를 제거한다.
  
  다음은 중위 표기법의 수식을 후위 표기법으로 변환하는 방법이다. 같은 수식 A*B-C/D를 이번에는 후위 표기법으로 변환해보자.
  (1), 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다.
  (2), 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동시킨다.
  (3), 괄호를 제거한다.
  
  다음은 컴퓨터 내부에서 중위 표기법을 후위 표기법으로 바꾸는 과정이다.
  스택을 이용하여 수식 A*B-C/D를 후위 표기식으로 변환해보자.
  (1), 왼쪽 괄호를 만나면 무시하고 다음 문자를 읽는다.
  (2), 피연산자를 만나면 출력한다.
  (3), 연산자를 만나면 스택에 삽입한다.
  (4), 오른쪽 괄호를 만나면 스택을 pop하여 출력한다.
  (5), 수식이 끝나면 스택이 공백이 될 때까지 pop하여 출력한다.
  
  5, 후위 표기 수식의 연산
  컴퓨터 내부에서 후위 표기법의 수식을 연산할 때에도 스택을 사용할 수 있다. 스택을 사용하여 수식을 계산하기 위한 처리 방법을 알아보자.
  (1), 피연산자를 만나면 스택에 삽입한다.
  (2), 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산 결과를 다시 스택에 삽입한다.
  (3), 수식이 끝나면, 마지막으로 스택을 pop하여 출력한다.
  
  
*/