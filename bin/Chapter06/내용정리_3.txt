/* 이중 연결 리스트
-이중연결리스트: 단순 연결 리스트에서 선행 노드에 접근하기가 어렵다는 점을 개선하여 원형 연결 리스트를 구성했지만, 원형 연결 리스트에서도
 원형 연결 리스트에서도 현재 노드의 바로 이전 노드에 접근하려면 전체 리스트를 한바퀴 순회해야 하는 문제가 있다.
 이러한 문제는 리스트의 링크가 한 방향으로만 되어있어서 반대 방향으로는 순회할 수 없기 때문에 발생한다. 이런 문제를 개선하여 양쪽 방향으로
 순회할 수 있도록 연결한 리스트를 이중 연결 리스트(Doubly Linked List)라고한다. 이중 연결 리스트의 노드 구조는 "두 개의 링크 필드"와
 "한 개의 데이터 필드"로 구성한다. link(left link)필드는 왼쪽 노드와 연결하는 링크 필드고, rlink(Right Link) 필드는 오른쪽 노드와
  연결하는 링크 필드다.
 
-이중 연결 리스트에서의 삽입 연산
 (1), 삽입할 노드를 가져온다.
 
 
 


-단순연결리스트vs원형연결리스트: 시작 노드에서 링크를 따라 이동하여 마지막 노드까지 순회할 수 있는데, 현재 노드에서 이전 노드를 접근(액세스)하려면
 현재 위치에 상관없이 항상 리스트의 첫 번째 노드부터 다시 시작해야 한다. 그러나 "마지막 노드"와 "첫 번째 노드"가 연결된 원형 연결 리스트에서는
 링크를 따라 계속 순회하면 이전 노드에 접근할 수 있다.
-삽입알고리즘
 1, 마지막 노드의 링크를 첫 번째 노드로 연결하는 부분만 제외하고는 단순 연결 리스트에서의 연산과 같다.
 2, 원형 연결 리스트에서는 리스트의 마지막에 노드를 삽입하는 것이 곧 리스트의 첫 번째에 노드를 삽입하는 것과 같은 의미다.
    따라서 원형 연결 리스트에서 노드를 삽입하는 경우는 노드의 첫 번째 노드로 삽입하는 경우와 중간 노드로 삽입하는 경우로 나눌 수 있다.
 3, 첫 번째 노드로 삽입하기
    3-1, "첫 번째 노드 삽입 알고리즘"은 단순 연결 리스트에서의 "첫 번째 노드 삽입 알고리즘"과 "마지막 노드 삽입 알고리즘"을 혼합한 형태가 된다.
    3-2, "공백 리스트인 경우"에는 삽입하는 노드 new가 리스트의 첫 번째 노드이자 마지막 노드다. ==> if(CL = null)
		 3-2-1, 원형 연결 리스트의 시작 노드에 대한 참조값을 저장하는 참조변수 "CL"에 삽입할 새노드에 대한 참조값(700)을 저장하여
	     	    "CL"이 노드 "new"를 "첫 번째 노드"로 가리키게 한다. ==> CL <- new;
		 3-2-2, 참조변수 new의 값(700)을 new가 가리키는 새 노드의 링크 필드(new.link)에 저장하여 노드 new가 자기 자신을 가리키게 함으로써
	            노드 new를 원형 연결 리스트 CL의 첫 번째 노드이자 마지막 노드가 되도록 지정한다. ==> new.link <- new;
	3-3, 리스트 CL이 "공백 리스트가 아닌 경우"에는 단순 연결 리스트에서의 마지막 노드 삽입 연산 과정이 수행된다. ==> else
		 3-3-1, CL의 값(100), 즉 리스트 CL의 첫 번째 노드에 대한 참조값(100)을
		        임시 순회 참조변수 "temp"에 저장하여 노드 순회의 시작 위치를 지정한다. ==> temp <- CL
		 3-3-2, while 문을 수행하여 "temp"를 링크를 따라 마지막 노드까지 이동시킨다.
		 	 	while (temp.link != CL)
		 	 	temp <- temp.link;
		 	 	==> temp.link가 CL(첫 번째노드)을 가리키면 temp에 담긴 노드는 "마지막 노드"다.
		 3-3-3, temp가 가리키는 노드, 즉 리스트의 마지막 노드의 링크 값(temp.link, 100)을 노드 new의 링크(new.link)에 저장하여
		 	    노드 new가 노드 temp의 다음 노드를 가리키게 한다. 리스트 CL은 원형 연결 리스트이므로 마지막 노드의 다음 노드는 리스트의 첫 번째
		 	    노드가 된다. 따라서 노드 new가 리스트 CL의 첫 번째 노드를 가리키게 된다. ==> new.link <- temp.link;
				"마지막노드는 새로 삽입된 노드를 가리키고, 새로 삽입된 노드는 마지막 노드를 가리킨다."
		 3-3-4, new의 값(700)을 temp가 가리키고 있는 마지막 노드의 링크(temp.link)에 저장하여
		        리스트의 마지막 노드가 노드 new를 가리키게 한다. ==> temp.link <- new;
		 3-3-5, new의 값(700), 즉 새 노드에 대한 참조값을 CL에 저장하여 노드 new가 리스트의 첫 번째 노드가 되도록 지정한다.
		        알고리즘 수행 결과, 삽입한 노드 new는 CL과 리스트의 첫 번째 사이에 삽입되면서 새로운 첫 번째 노드가 되었고,
		        리스트의 마지막 노드와 연결하여 원형 연결 리스트 상태를 유지하도록 하였다.
 4, 중간 노드로 삽입하기
 	4-1, 노드 new를 삽입할 원형 연결 리스트 CL이 공백 리스트인 경우에 중간 노드로 삽입하는 방법은 공백 리스트인 경우에 첫 번째 노드로
 	     삽입하는 방법과 같다. ==> if(CL = null)
	4-2, "리스트가 공백 리스트가 아닌 경우"에는 pre가 가리키는 노드 뒤에 노드 new를 삽입한다.
		 4-2-1, 노드 pre의 다음 노드로 노드 new를 삽입하기 위해 
		 먼저 노드 pre의 다음 노드(pre.link, 300)를 new의 다음 노드(new.link)로 연결한다. ==> new.link <- pre.link;
 		 4-2-2, new의 값(700)을 노드 pre의 링크(pre.link)에 저장하여, 노드 new를 노드 pre의 다음 노드로 연결한다. ==> pre.link <- new;
-삭제 알고리즘
 1, 원형 연결 리스트의 원소 삭제
 	1-1, 노드 pre의 다음 노드(pre.link, 300)를 삭제할 노드 old로 지정한다. ==> old <- pre.link
	1-2, 삭제할 노드 old의 다음 노드(old.link, 400)를 노드 pre의 다음 노드(pre.link)로 지정한다. ==> pre.link <- old.link
    1-3, 삭제할 노드 old가 CL이라면 삭제할 노드 old는 리스트 CL의 첫 번째 노드가 된다. ==> if(old = CL)
		 1-3-1, 첫 번째 노드를 삭제하는 경우에는 원형 연결 리스트의 연결이 끊어지지 않도록 하기 위해서 CL에 대한 연결 처리가 추가로 필요하다.
		 노드 old의 링크값(old.link, 200)을 리스트 참조변수 CL에 저장하여 두 번째 노드가 리스트의 첫 번째 노드가 되도록 조정한다. ==> CL <- old.link;
 	1-4, 리스트 CL에 대한 노드 삭제 연산이 완성되었으므로 삭제한 노드 old를 자유 공간 리스트에 반환한다. ==> returnNode(old)
*/