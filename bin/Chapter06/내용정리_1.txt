-단순연결리스트: 노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가진 연결 리스트다.
 단순연결리스트==연결리스트==선형연결리스트==단순연결선형리스트
 물리적 순서를 유지하기 위해서 원소를 이동시키지 않고 링크필드의 참조값에 대한 연산만으로 쉽게 삽입 할수 있다는 장점이 있다.

/*
-자유공간리스트: 메모리를 사용하기 전에 미리 노드로 나누어서 연결해 놓은 리스트를 자유 공간 리스트(Free space List)라고 한다.
-getNode(): 자유공간으로부터 공백노드를 할당받아 그 메모리 주소에 대한 참조값을 반환 하는 함수
-returnNode(old): 사용이 끝난 노드를 참조변수 old를 사용하여 자유 공간 리스트에 반환하는 함수다.
 1,자유공간리스트에서 첫 번째 노드에 대한 참조값(100)을 참조변수 new에 저장하여 new가 자유공간리스트의 첫 번째 노드를 가리키게 한다.
 2,자유공간리스트에서 두 번째 노드에 대한 참조값(200)을 자유공간리스트의 변수인 Free에 저장한다.
 3,Free(자유공간리스트변수)의 첫 번째 노드는 리스트에서 의미적으로 분리된 상태이므로 new를 반환(return new;)해줌으로써 새 노드를 할당해주게 된다.
 4,returnNode(old) 함수를 이용해 사용이 끝난 노드를 참조변수 old를 사용하여 자유공간리스트에 반환한다.
 5,(new<Free, Free<Free.link, old.link<Free, Free<old)
-삽입알고리즘
 1,처음, 중간, 마지막 노드로 삽입하는 경우 3가지가 존재한다. 
 2,첫 번째 노드로 삽입하기
   2-1,삽입할 노드를 자유 공간 리스트에서 할당받는다. ==> new <- getNode();
   2-2,새 노드의 데이터 필드에 x를 저장한다. ==> new.data <- x;
   2-3,리스트 L의 첫 번째 노드에 대한 참조값을 삽입할 새 노드 new의 링크 필드에 저장 함으로써 새 노드 new를 리스트 L의 첫 번째 노드와 연결한다. ==> new link <- L;
   2-4,참조변수 L에 새 노드에 대한 참조값(700)을저장하여 L이 새 노드 new를 첫 번째 노드로 가리키도록 지정한다.
   2-5,참조변수 L은 새로삽일될 노드의 참조값(700)이 저장되고, 새로운 노드의 링크필드는 기존의 첫번째 노드의 참조값(100)을 가리켜 첫 번째 노드로 삽입한다.
 3,중간 노드로 삽입하기
   3-1,중간에 노드를 삽입하기 위해서는 삽일할 위치의 앞에 있는 선행자 노드를 알려주는 참조변수 pre가 필요하다.
   3-2,리스트 L이 공백 리스트인 경우에 수행할 연산이다. ==> if(L=null)
   	   참조변수 L에 새 노드에 대한 참조값(700)을 저장하여 새 노드 new가 리스트 L의 첫 번째 노드가 되도록 한다. ==> (L <- new);
   3-3,공백 리스트에 최초의 값이 삽입 됐으면, 새노드 new는 리스트L의 마지막 노드가 된다.
       따라서 새 노드 new의 링크 필드에 null을 저장하여 마지막 노드임을 표시한다. ==> (new.link <- null);
   3-4,리스트 L이 공백 리스트가 아닌 경우에는 일반적인 노드 삽입 연산을 수행한다. ==> else
       참조변수 pre는 삽일할 위치의 앞 노드를 가리킨다. 따라서 
       pre가 가리키는 노드의 다음 노드로 새 노드 new를 연결해야 하므로 노드 pre의 링크 필드값(pre.link, 200)을
       노드 new의 링크 필드(new.link)에 저장하여, 새 노드new가 노드 pre의 다음 노드를 가리키게 한다. ==> (new.link <- pre.link);
   3-5,new의 값(700)을 노드 pre의 링크 필드(pre.link)에 저장하여 pre가 가리키는 노드의 다음 노드로서 새 노드 new를 연결한다. ==> (pre.link <- new)
 4,마지막 노드로 삽입하기
   4-1,새 노드 new를 마지막 노드로 삽입하기 위해서는 먼저 리스트의 마지막 노드를 찾아야 하는데, 마지막 노드는 링크 필드가 null이다.
   4-2,리스트 L이 공백 리스트인 경우에 마지막 노드의 삽입 연산은 새 노드 new가 리스트 L의 첫 번째 노드이자 미자막 노드가 된다. ==> if(L = null)
   4-3,리스트 L이 공백이 아닌 경우에는 마지막 노드 삽입 연산 과정이 수행된다.
   	   마지막 노드로 삽입하기 위해서는 리스트 L의 현재 마지막 노드를 먼저 찾아야 한다. 
   	   		노드를 순회할 참조변수 temp에 리스트 첫 번째 노드 주소 (L,100)을 지정한다. ==> temp <- L
   	   while 반복문을 수행하는 동안 temp가 노드의 링크 필드를 따라 이동하면서 링크 필드가 null인 마지막 노드를 찾도록 한다. ==> temp <- temp.link
	   temp가 가리키는 노드, 즉 리스트 L의 마지막 노드의 링크 필드(temp.link)에 삽입할 새 노드 new의참조값(700)을 저장하여 
	   		리스트 L의 마지막 노드 뒤에 새 노드 new를 연결하게 한다. 이제 new 노드가 리스트의 마지막 노드가 된다.
-삭제 알고리즘
 1,리스트 L에서 pre가 가리키는 노드의 다음 노드를 삭제하는 알고리즘은 다음과 같다. old는 삭제할 노드를 알려주기 위해 사용한다.
 2,삭제 연산을 수행하려면 리스트에 노드가 하나 이상 있어야 한다. 따라서 삭제 연산을 수행하기 전에 먼저 리스트 L이 공백 리스트인지를 검사하여
       공백 리스트인 경우에는 에러 처리하고, 삭제 연산 수행을 중단한다. ==> if (L = null) then error;
 3,리스트 L이 공백 리스트가 아닌 경우, 즉 삭제 연산을 수행할 수 있는 노드가 하나 이상 있는 경우에 노드 삭제 연산을 수행한다. ==> else
 	3-1,old는 삭제할 노드를 지시해야 하므로 노드 pre의 링크 필드값(pre.link), 즉 노드 pre의 다음 노드에 대한 참조값(300)을 old에 저장하여
 		삭제할 노드를 가리키게 한다. ==> old <- pre.link;   	
    3-2,삭제할 노드 old의 다음 노드(old.link, 400)를 노드 pre의 다음 노드(pre.link)로 연결한다. ==> pre.link <- old.link
    3-3,삭제한 노드 old를 자유 공간 리스트에 반환한다. ==> returnNode(old);
 4,만약 노드 pre가 리스트의 마지막 노드였다면 pre.link 값은 null이므로(old <- pre.link)를 수행 한 후의 old 값은 null이 된다.
   old의 값이 null이라는 것은 노드 pre 뒤에 삭제할 노드가 없다는 의미이므로 삭제 연산을 더 이상 수행하지 못한다.
   old의 값이 null이 아니고 삭제할 노드가 있는 경우에 삭제 연산을 수행하고 노드 old를 자유 공간 리스트에 반환한다.	 
*/







 