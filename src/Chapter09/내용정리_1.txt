/*
●트리
리스트와 스택, 큐는 자료들이 선의 형태로 나열되어 있는 구조를 가진 선형 자료구조(Linear Data Structure)였다.
자료들이 나열된 구조가 선형이 아닌 자료구조를 비선형 자료구조라고 하는데, 트리(tree)는 비선형 자료구조 중에서
자료들 간에 계층관계를 가진 계층형 자료구조(Hierarchical Data Structrue)다.

트리를 구성하는 원소(자료)를 "노드"라고 하고 노드를 연결하는 선을 "간선"(edge)이라 한다.
트리의 시작 노드를 루트 노드(Root Node)라 하고 레벨(levl) 0이 된다. 같은 부모노드의 자식노드들은 서로 형제노드가 된다.
한 노드에서 간선을 따라 루트 노드까지 이리는 경로에 있는 노드들은 모두 그 노드의 조상 노드가 된다.
자식노드들은 각각 독립하여 새로운 트리를 구성 할 수 있으므로 각 노드는 자식노드 수만큼 서브 트리를 갖는다.
한 노드의 자손 노드들은 그 노드의 서브 트리에 있는 노드들이 된다.

한 노드가 가지는 서브 트리의 수, 즉 자식노드의 수를 그 노드의 차수라 한다.
한 노드의 높이는 루트에서 그 노드에 이르는 경로에 있는 간선의 수가 되고, 노드의 높이 중에서 가장 큰 높이,
즉 최대 레벨이 그 트리의 전체 높이가 된다.

●이진트리
1, 이진 트리의 개요
트리의 노드 구조를 일정하게 정의하면 트리의 연산이 단화화되어 쉬워진다. 
그래서 모든 노드의 차수를 2 이하로 정하여 전체 트리의 차수가 2이하가 되도록 만든 것이 이진 트리(Binary Tree)다.

이진 트리는 왼쪽 자식노드와 오른쪽 자식노드 2개만을 가질 수 있으며, 공백 노드도 이진 트리의 노드로 취급한다.
왼쪽 자식노드와 공백 노드인 오른쪽 자식노드를 가진 이진 트리이며 공백 노드를 왼쪽 자식노드로 가지고 있는 이진 트리가 된다.
자식노드가 없는 단말 노드는 왼쪽 자식노드와 오른쪽 자식노드가 모두 공백 노드인 이진 트리다

이진 트리에 있는 모든 노드는 왼쪽 자식노드를 루트로 하는 왼쪽 서브 트리와 오른쪽 자식 노드를 루트로 하는 오른쪽 서브 트리를 가진다
그리고 이진 트리의 서브 트리들 역시 모두 이진 트리여야 한다.

이진 트리는 루트 A의 왼쪽 자식노드 B를 루트로 하는 왼쪽 서브 트리와 오른쪽 자식노드 C를 루트로 하는 오른쪽 서브 트리가 있다.
그리고 왼쪽 서브 트리의 루트 B는 왼쪽 자식노드 D를 루트로 하는 왼쪽 서브 트리와 오른쪽 자식노드 E를 루트로 하는 오른쪽 서브 트리를 가지고 있다.
마찬가지로 오른쪽 서브 트리의 루트 C는 왼족 자식노드F를 루트로 하는 왼쪽 서브 트리와 오른쪽 자식노드 G를 루트로 하는 오른쪽 서브 트리를 가진다.

2, 이진 트리의 추상 자료형
이진 트리의 추상 자료형에 따라서 만들어진 이진 트리가 갖는 특징을 다음과 같이 정의할 수 있다.
[정의 1] n개의 노드를 가진 이진 트리는 항상(n-1)개의 간선을 가진다.
이진 트리에서 루트 이외의 모든 노드는 한 개의 부모노드를 가지므로 부모노드와 연결하는 한 개의 간선을 갖는다.
따라서 n개의 노드로 구성된 이진 트리에서 루트를 제외한 나머지 노드의 개수가(n-1)개 이므로(n-1)개의 간선이 있게 된다.
[정의 2] 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개가 되며, 최대개수는 (2^h+1 - 1)개가 된다.
이진 트리의 높이가 h가 되려면 한 레벨에 최소한 한 개의 노드가 있어야 하므로 높이가 h인 이진 트리의 최소 노드의 개수는(h+1)개가 된다.
그리고 하나의 노드는 최대 2개의 자식 노드를 가질 수 있으므로 레벨 i에서의 노드의 최대 개수는 2^i가 된다.
따라서 높이가 h인 이진 트리 전체의 노드 개수는 2^h+1-1이 된다.




●큐의 구조
- 큐(Queue)는 스택과 마찬가지로 삽입과 삭제의 위치와 방법이 제한되어 있는 유한 순서 리스트지만,
  스택과 달리 리스트의 한쪽 끝에서는 삽입 작업이 이루어지고 반대쪽 끝에서는 삭제 작업이 이루어져서,
  삽입된 순서대로 삭제되는 선입선출의 구조로 운영된다.
- 큐는 한쪽 끝은 프런트(front)로 정하여 삭제 연산만 수행하도록 하고, 다른 쪽 끝은 리어(rear)로 정하여
  삽입 연산만 수행하도록 제한한다. 큐에서 프런트 원소는 가장 먼저 큐에 들어온 첫 번째 원소이고,
  리어 원소는 큐에 가장 늦게 들어온 마지막 원소다.
- 큐의 리어(삽입되는 곳)에서 이루어지는 삽입 연산을 인큐(enQueue)라고 하고, 프런트에서 이루어지는 
  삭제 연산을 디큐(deQueue)라고 한다.
●큐의 추상 자료형
(1), 공백 큐 생성:createQueue(); ==> front와 rear가 같은 위치에 있다.
(2), 원소 A 삽입:enQueue(Q,A);
(3), 원소 B 삽입:enQueue(Q,B);
(4), 원소 삭제:deQueue(Q);
(5), 원소 C 삽입:enQueue(Q,C);
(6), 원소 삭제:deQueue(Q);
(7), 원소 삭제:deQueue(Q); ==> front와 rear가 같아 진다.
==> 초기
●순차 자료구조 방식을 이용한 큐의 구현
- 선형 큐:1차원 배열을 사용하여 순차 자료구조 방식으로 큐를 구현해보자. 이때 배열의 크기는 큐의 크기, 
  즉 큐에 저장할 수 있는 최대 원소의 개수가 된다. 그리고 배열에 저장된 원소 중에서 첫 번째 원소의 인덱스를 저장할 front 변수와
  저장된 마지막 원소의 인덱스를 저장할 rear변수를 사용한다. 초기 공백 큐의 상태는 front 변수와 rear 변수의 값을 -1로 설정한다.
	- 큐에 최대로 저장할 수 있는 원소 개수를 배열을 크기로 하는 1차원 배열을 선언한다. 새로 생성하여 저장된 원소가 없는
  	공백 큐이므로 front와 rear -1로 초기화한다.
	- 큐가 공백인 경우는 createQueue() 연산으로 공백 큐를 생성하여 front==-1, rear=-1인 경우와
  	마지막에 삽입한 rear의 원소를 삭제하여 front가 rear의 위치에 있는 경우가 있다.
  	이때 front와 rear는 같은 값을 갖게 되므로 조건문 if(front=rear)의 결과 값이 참(true)이 된다.
  	큐가 포화 상태인 경우는 배열의 마지막 인덱스까지 원소가 저장된 경우므로 큐에 저장된 마지막 원소의 인덱스, 즉
  	rear의 값이 배열의 마지막 인덱스(n-1)인가를 검사한다.
	- 포화 상태가 아닌 큐에 원소를 삽입하려면 배열에 저장되어 있는 마지막 원소의 다음 자리에 삽입해야 하므로
  	마지막 원소의 인덱스를 저장한 rear의 값을 하나 증가시켜 삽입할 자리를 준비하고, 그 인덱스에 해당하는 배열 원소
  	Q[rear]에 item을 저장한다.
	- 공백 상태가 아닌 큐에서 원소의 삭제는 언제나 큐에 저장된 원소 중에서 가장 앞에 있는 원소, 즉 가장 먼저 큐에 들어와
  	있는 원소를 가장 먼저 삭제해야 한다. 그러기 위해서 front의 위치를 한 자리 뒤로 조정하여 큐에 남아있는 첫 번째 원소의
  	위치로 이동하여 삭제할 자리를 준비하고, 그 자리의 원소를 삭제하여 반환한다. delete() 연산은 front의 원소를 삭제하는
  	연산이고, deQueue() 연산은 front의 원소를 삭제하고 삭제한 원소를 반환하는 연산이다.
	- 큐에서의 검색은 큐에 있는 원소 중에서 가장 먼저 들어와 있는 원소, 즉 Q[front+1]에 있는 원소를 검색하여 반환하는 연산이다.
- 원형 큐:1차원 배열을 사용한 순차 자료구조 방식에는 큐가 포화 상태가 아닐 경우에만 삽입 연산을 수행하도록 정의되어 있다.
	포화 상태를 확인하기 위해서 큐의 rear가 배열의 마지막 위치에 있기 때문에 앞에 빈자리가 있는데도 포화 상태로 인식하고 삽입 연산을 수행하지 않는다.
	- 이런 경우에는 큐의 빈자리를 사용하려면 저장되어 있는 원소를 배열의 앞부분으로 이동시켜서 위치를 조정해줘야 한다.
	그러나 이와 같은 이동 작업은 연산이 복잡하여 큐의 효율성을 떨어뜨린다.
	- 이러한 선형 큐의 문제를 해결하기 위해 원형 큐(Circular Queue)를 사용한다. 원형 큐는 선형 큐와 마찬가지로 1차원 배열을 사용하는데,
	논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 생각하는 것이다.
	- 원형 큐에서는 초기 공백 상태일 때 front와 rear의 값이 0이 되고, 공백 상태와 포화 상태를 쉽게 구분하기 위해서 자리 하나를 항상 비워둔다.
	원형 큐에서의 공백 상태 조건은 front=rear가 된다. rear는 앞으로 이동하면서 원소를 삽입하고 front는 rear가 이동한 방향으로 따라가면서 원소를 삭제한다.
    원형 큐에서의 배열의 인덱스가 n-1 다음에 다시 0이 되어야 하므로 사용할 다음 인덱스를 정하기 위해서 나머지 연산자 mod를 사용한다.
- 원형 큐 알고리즘
	- 초기 공백 원형 큐의 생성 알고리즘:원형 큐 역시 선형 큐와 마찬가지로 1차원 배열을 사용한다.
	새로 생성한 공백 원형 큐는 front와 rear의 초기값으로 0을 설정한다.
	- 원형 큐의 공백 상태 검사 알고리즘과 포화 상태 검사 알고리즘:원형 큐에서 공백 상태가 되는 경우는 createQueue() 연산을
	수행하여 공백 원형 큐를 생성한(front=rear=0) 경우와 마지막에 삽입한 rear의 원소를 삭제하여 front가 rear의
	위치에 있는 경우가 있다. 두 가지 경우의 공백 상태에서는 front와 rear가 항상 같은 위치에 있게 되어 front=rear 상태가 된다.
	rear가 원형 큐를 한바퀴 돌면서 원소를 삽입하여 큐를 모두 채우면 rear의 다음 위치(rear+1) mod n)는 현재의 front 위치가 되어
	더 이상 원소를 삽입할 수 없는 포화 상태가 된다.
	- 원형 큐의 삽입 알고리즘:원형 큐의 현재 상태가 포화 상태가 아닌 경우에만 삽입 연산을 수행한다. 삽입 연산은 먼저
	1, rear의 값을 조정하여 삽입할 자리를 준비하고
	2, 준비한 자리 cQ[rear]에 원소 item을 삽입한다. 원형 큐에서 삽입할 자리를 정하기 위해서 나머지 연산자 mod를 사용한다.
	크기가 4인 원형 큐에서 현재 rear의 위치가 2라면 (2+1) mod 4 = 3이 되어 삽입할 다음 위치는 cQ[3]이 되고, 
	현재 rear의 위치가 3이라면(3+1) mod 4 = 0이 되어 삽입할 다음 위치는 cQ[0]이 된다.
	- 원형 큐의 삭제 알고리즘:현재 원형 큐의 상태가 공백 상태가 아닌 경우에만 삭제 연산을 수행한다. 삭제 연산은 먼저
	(1), front의 값을 조정하여 삭제할 자리를 준비하고
	(2), 준비한 자리에 있는 원소cQ[front]를 삭제하여 반환한다. 원형 큐에서 삭제할 위치를 정하기 위해서 나머지 연산자 mod를 사용한다.
	==> 320Page 끝, 321~322 이후에 소스코드 작성
	==> 326Page부터 다시 시작
●연결 자료구조 방식을 이용한 큐의 구현
	- 연결 큐:순차 자료구조 방식을 이용하여 구현한 큐에는 몇 가지 문제가 있다. 사용 크기가 제한되어 있어서 큐의 길이를 마음대로 변경할 수 없고,
	원소가 없을 때에도 항상 처음 크기를 유지하고 있어야 하므로 메모리도 낭비된다. 이와 같은 문제를 극복하기 위해 연결 자료구조 방식을 이용하여 크기에
	제한이 없는 연결 큐(Linked Queue)를 구현해보자.

	연결 큐에서 원소는 데이터 필드와 링크 필드를 가진 노드로 구성하며, 첫 번째 노드를 가리키는 참조변수 front와 마지막 노드를 가리키는 참조변수 rear를 사용한다.
	연결 큐의 초기 상태(공백 큐)는 front와 rear를 널(NULL)로 설정하여 표현한다.	
	- 연결 큐의 삽입 알고리즘
	(1), 삽입할 새 노드를 생성하여 데이터 필드에 item을 저장한다. 삽입할 새 노드는 연결 큐의 마지막 노드가 되어야 하므로 링크 필드에 null을 저장한다.
    (2), 새 노드를 삽입하기 전에 연결 큐가 공백인지 아닌지를 먼저 검사한다. 연결 큐가 공백인 경우에는
    삽입할 새 노드가 큐의 첫 번째 노드이자 마지막 노드이므로 참조변수 front와 rear가 모두 새 노드를 가리키도록 설정한다.
	(3), 큐가 공백이 아닌 경우, 즉 노드가 있는 경우에는 현재 큐의 마지막 노드의 뒤에 새 노드를 삽입한다.
	그리고 마지막 노드를 가리키는 rear가 삽입한 새 노드를 가리키도록 설정한다.
	- 연결 큐의 삭제 알고리즘(큐에서의 삭제 연산은 큐가 공백이 아닌 경우에만 수행한다.)
	(1), 삭제 연산에서 삭제할 노드는 front가 가리키고 있는 첫 번째 노드다.
	front가 가리키는 노드를 참조변수 old가 가리키게 하여 삭제할 노드를 지정한다.
	(2), 삭제 연산 후에는 현재 front 노드의 다음 노드가 front 노드가 되어야 하므로 front를 그 다음 노드(front.link)로 재설정한다.
	(3), 현재 큐에 노드가 하나뿐이어서 재설정한 front가 null이 되는 경우에는 삭제 연산 후에 공백 큐가 될 것이므로 rear를 null로 설정해준다.
	(4), old가 가리키고 있는 노드를 삭제하여 메모리 공간을 시스템에 반환한다.
	- 연결 큐의 검색 알고리즘(큐에서의 검색 연산은 항상 큐의 첫 번째 노드, 즉 front 노드의 데이터 필드 값을 반환한다.)
	(1), 공백 큐 생성: createLinkedQueue();
	(2), 원소 A 삽입 : enQueue(LQ,A);
	(3), 원소 B 삽입 : enQueue(LQ,B);
	(4), 원소 삭제 : deQueue(LQ);
	(5), 원소 C 삽입 : enQueue(LQ, C);
	(6), 원소 삭제 : deQueue(LQ);
	(7), 원소 삭제 : deQueue(LQ);
	
● 덱의 구조
- 덱은 큐의 양쪽 끝에서 삽입과 삭제가 모두 발생할 수 있는 큐로서, 스택의 성질과 큐의 성질을 모두 가지고 있는 자료구조다.
덱의 연산은 스택과 큐의 연산을 모두 가지고 있다. 덱의 insertFront() 연산과 deleteFront() 연산은 front를
스택의 top으로 생각했을 때 스택의 push() 연산, pop() 연산과 같고, 덱의 insertRear() 연산과 deleteRear() 연산은 rear를 스택의 top으로 생각
했을 때 스택의 push() 연산, pop() 연산과 같다. 그리고 덱의 insertRear() 연산과 
deleteFront() 연산은 일반 큐의 enQueue()연산, deQueue() 연산과 같다.

1, createDeque();
2, insertFront(DQ, 'A') ==> DQ('A')
3, insertFront(DQ, 'B') ==> DQ('B', 'A')
4, insertRead(DQ, 'C') ==> DQ('B', 'A', 'C')
5, deleteFront(DQ) ==> DQ('A', 'C')
6, deleteRear(DQ) ==> DQ('A')
7, insertRear(DQ, 'D') ==> DQ('A', 'B')
8, insertFront(DQ, 'E') ==> DQ('E', 'A', 'D')
9, insertFront(DQ, 'F') ==> DQ('F', 'E', 'A', D)
==> 덱은 양쪽 끝에서 삽입/삭제 연산이 가능해야 하기 때문에 다음과 같이 왼쪽 링크 필드와 오른쪽 링크 필드를 가지는 노드를
사용하는 이중 연결 리스트를 이용하여 구현한다.
*/