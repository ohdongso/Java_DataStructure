/*
●큐의 구조
- 큐(Queue)는 스택과 마찬가지로 삽입과 삭제의 위치와 방법이 제한되어 있는 유한 순서 리스트지만,
  스택과 달리 리스트의 한쪽 끝에서는 삽입 작업이 이루어지고 반대쪽 끝에서는 삭제 작업이 이루어져서,
  삽입된 순서대로 삭제되는 선입선출의 구조로 운영된다.
- 큐는 한쪽 끝은 프런트(front)로 정하여 삭제 연산만 수행하도록 하고, 다른 쪽 끝은 리어(rear)로 정하여
  삽입 연산만 수행하도록 제한한다. 큐에서 프런트 원소는 가장 먼저 큐에 들어온 첫 번째 원소이고,
  리어 원소는 큐에 가장 늦게 들어온 마지막 원소다.
- 큐의 리어(삽입되는 곳)에서 이루어지는 삽입 연산을 인큐(enQueue)라고 하고, 프런트에서 이루어지는 
  삭제 연산을 디큐(deQueue)라고 한다.
●큐의 추상 자료형
(1), 공백 큐 생성:createQueue(); ==> front와 rear가 같은 위치에 있다.
(2), 원소 A 삽입:enQueue(Q,A);
(3), 원소 B 삽입:enQueue(Q,B);
(4), 원소 삭제:deQueue(Q);
(5), 원소 C 삽입:enQueue(Q,C);
(6), 원소 삭제:deQueue(Q);
(7), 원소 삭제:deQueue(Q); ==> front와 rear가 같아 진다.
==> 초기
●순차 자료구조 방식을 이용한 큐의 구현
- 선형 큐:1차원 배열을 사용하여 순차 자료구조 방식으로 큐를 구현해보자. 이때 배열의 크기는 큐의 크기, 
  즉 큐에 저장할 수 있는 최대 원소의 개수가 된다. 그리고 배열에 저장된 원소 중에서 첫 번째 원소의 인덱스를 저장할 front 변수와
  저장된 마지막 원소의 인덱스를 저장할 rear변수를 사용한다. 초기 공백 큐의 상태는 front 변수와 rear 변수의 값을 -1로 설정한다.
	- 큐에 최대로 저장할 수 있는 원소 개수를 배열을 크기로 하는 1차원 배열을 선언한다. 새로 생성하여 저장된 원소가 없는
  	공백 큐이므로 front와 rear -1로 초기화한다.
	- 큐가 공백인 경우는 createQueue() 연산으로 공백 큐를 생성하여 front==-1, rear=-1인 경우와
  	마지막에 삽입한 rear의 원소를 삭제하여 front가 rear의 위치에 있는 경우가 있다.
  	이때 front와 rear는 같은 값을 갖게 되므로 조건문 if(front=rear)의 결과 값이 참(true)이 된다.
  	큐가 포화 상태인 경우는 배열의 마지막 인덱스까지 원소가 저장된 경우므로 큐에 저장된 마지막 원소의 인덱스, 즉
  	rear의 값이 배열의 마지막 인덱스(n-1)인가를 검사한다.
	- 포화 상태가 아닌 큐에 원소를 삽입하려면 배열에 저장되어 있는 마지막 원소의 다음 자리에 삽입해야 하므로
  	마지막 원소의 인덱스를 저장한 rear의 값을 하나 증가시켜 삽입할 자리를 준비하고, 그 인덱스에 해당하는 배열 원소
  	Q[rear]에 item을 저장한다.
	- 공백 상태가 아닌 큐에서 원소의 삭제는 언제나 큐에 저장된 원소 중에서 가장 앞에 있는 원소, 즉 가장 먼저 큐에 들어와
  	있는 원소를 가장 먼저 삭제해야 한다. 그러기 위해서 front의 위치를 한 자리 뒤로 조정하여 큐에 남아있는 첫 번째 원소의
  	위치로 이동하여 삭제할 자리를 준비하고, 그 자리의 원소를 삭제하여 반환한다. delete() 연산은 front의 원소를 삭제하는
  	연산이고, deQueue() 연산은 front의 원소를 삭제하고 삭제한 원소를 반환하는 연산이다.
	- 큐에서의 검색은 큐에 있는 원소 중에서 가장 먼저 들어와 있는 원소, 즉 Q[front+1]에 있는 원소를 검색하여 반환하는 연산이다.
- 원형 큐:1차원 배열을 사용한 순차 자료구조 방식에는 큐가 포화 상태가 아닐 경우에만 삽입 연산을 수행하도록 정의되어 있다.
	포화 상태를 확인하기 위해서 큐의 rear가 배열의 마지막 위치에 있기 때문에 앞에 빈자리가 있는데도 포화 상태로 인식하고 삽입 연산을 수행하지 않는다.
	- 이런 경우에는 큐의 빈자리를 사용하려면 저장되어 있는 원소를 배열의 앞부분으로 이동시켜서 위치를 조정해줘야 한다.
	그러나 이와 같은 이동 작업은 연산이 복잡하여 큐의 효율성을 떨어뜨린다.
	- 이러한 선형 큐의 문제를 해결하기 위해 원형 큐(Circular Queue)를 사용한다. 원형 큐는 선형 큐와 마찬가지로 1차원 배열을 사용하는데,
	논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 생각하는 것이다.
	- 원형 큐에서는 초기 공백 상태일 때 front와 rear의 값이 0이 되고, 공백 상태와 포화 상태를 쉽게 구분하기 위해서 자리 하나를 항상 비워둔다.
	원형 큐에서의 공백 상태 조건은 front=rear가 된다. rear는 앞으로 이동하면서 원소를 삽입하고 front는 rear가 이동한 방향으로 따라가면서 원소를 삭제한다.
    원형 큐에서의 배열의 인덱스가 n-1 다음에 다시 0이 되어야 하므로 사용할 다음 인덱스를 정하기 위해서 나머지 연산자 mod를 사용한다.
- 원형 큐 알고리즘
	- 초기 공백 원형 큐의 생성 알고리즘:원형 큐 역시 선형 큐와 마찬가지로 1차원 배열을 사용한다.
	새로 생성한 공백 원형 큐는 front와 rear의 초기값으로 0을 설정한다.
	- 원형 큐의 공백 상태 검사 알고리즘과 포화 상태 검사 알고리즘:원형 큐에서 공백 상태가 되는 경우는 createQueue() 연산을
	수행하여 공백 원형 큐를 생성한(front=rear=0) 경우와 마지막에 삽입한 rear의 원소를 삭제하여 front가 rear의
	위치에 있는 경우가 있다. 두 가지 경우의 공백 상태에서는 front와 rear가 항상 같은 위치에 있게 되어 front=rear 상태가 된다.
	rear가 원형 큐를 한바퀴 돌면서 원소를 삽입하여 큐를 모두 채우면 rear의 다음 위치(rear+1) mod n)는 현재의 front 위치가 되어
	더 이상 원소를 삽입할 수 없는 포화 상태가 된다.
	- 원형 큐의 삽입 알고리즘:==>여기서부터





●스택
- 스택(stack)이란 쌓아 올린다는 의미다. 따라서 스택 자료구조라는 것은 접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 형태의 구조를 말한다.
  스택의 형태는 뷔폐식당의 쌓인 접시, 책상 위에 쌓아 둔 책, 안하고 밀려서 쌓인 레포트 등 주변에서 흔히 볼 수 있다.  
  스택은 같은 구조와 크기의 자료를 top이라고 정한 한 곳으로만 쌓을 수 있고, top으로만 접근하도록 제한하여 만든 자료구조다.
- 스택에서는 top을 통해서 들어온 자료가 일정한 방향으로 차곡차곡 쌓인다. 삽입되는 새자료는 top이 가리키고 있는 자료의 위에 쌓인다.
  이때 새로 삽입된 자료는 스택의 마지막 자료가 되고, top이 이 자료를 가리키게 된다. 스택에서 자료를 삭제할 때도 top을 통해서
  만 가능하기 때문에 top이 가리키고 있는 스택의 마지막 자료만 삭제할 수 있다. 따라서 스택은 시간순서에 따라 자료가 쌓이고, 삭제할 때는
  가장 마지막에 삽입된 자료가 가장 먼저 삭제되는 후입선출(Lifo, Last-In-First-Out)의 구조를 갖는다.
- 스택에서 top을 통한 삽입 연산을 push, top을 통한 삭제 연산을 pop이라고 한다.
  ● 스택 S에 자료 x를 삽입하는 push() 알고리즘을 정의하면 다음과 같다.
  1-1, 스택 S에서 top이 마지막 자료를 가리키고 있으므로 그 위에 자료를 삽입하려면 먼저 top의 위치를 하나 증가시킨다.
  이때 top의 위치가 스택의 크기(stack_SIZE)보다 크다면 오버플로우(overflow) 상태가 되므로 삽입 연산을 수행하지 못하고 연산이 종료된다. (top <- top+1;)
  1-2, 오버플로우 상태가 아니라면 스택의 top이 가리키는 위치에 x를 삽입한다. ==> S(top)
  ● 다음은 스택 S에서 자료를 삭제하는 pop() 알고리즘이다.
  스택에서의 삭제 연산은 스택의 마지막 자료 즉, top이 가리키고 있는 자료를 스택에서 삭제하고 삭제한 자료를 반환하는 것이다.
  그런데 만약 top의 값이 0인 공백 스택이라면 삭제할 자료가 없으므로 삭제 연산을 수행하지 못한다.
  2-1, 스택이 공백 스택이 아니라면 top이 가리키는 원소를 먼저 반환한다. ==> return S(top)
  2-2, 스택의 마지막 자료가 삭제되면 top의위치는 그 아래의 자료가 되므로 top의 위치를 하나 감소시킨다. ==> top <- top-1
  
●스택의 구현
  1, 순차 자료구조방식을 이용한 스택의 구현
  순차 자료구조인 1차원 배열을 이용하여 스택을 구현할 수 있다. 1차원 배열 stack[n]을 사용할 때 n은 배열 크기로서 
  배열원소의 개수를 나타내는데, 이것이 스택의 크기가 된다. 스택에 원소가 쌓이는 순서는 배열의 인덱스(index)로 표현한다.
  따라서 스택의 첫 번째 원소는 stack[0]에 저장하고, 스택의 두 번째 원소는 stack[1]에 저장하고, 
  스택의 i번째 원소는 stack[i-1]에 저장된다.
  
  스택의 top을 표현하기 위해서 배열 stack의 마지막 원소의 인덱스를 변수 top에 저장한다.
  변수 top은 0부터 n-1까지의 인덱스를 저장하므로, 스택이 초기상태(공백스택)일 때 top에는 -1을 저장한다.
  
  크기가 5인 스택을 생성하여 원소 A, B, C를 순서대로 삽입한 후에 원소 하나를 삭제하는 과정을 살펴보자.
  (1), 공백 스택 생성 : Create(stack, 5);
  (2), 원소 A 삽입 : push(stack, A);
  (3), 원소 B 삽입 : push(stack, B);
  (4), 원소 C 삽입 : push(stack, C);
  (5), 원소 삭제 : pop(stack);
  
  2, 연결 자료구조 방식을 이용한 스택의 구현
  순차 자료구조를 이용한 스택은 배열을 사용하여 구현하기는 쉽지만, 물리적으로 크기가 고정된 배열을 사용하기 때문에 스택의 크기를 변경하기가 어렵고,
  메모리의 낭비가 생길 수 있다는 문제가 있다. 이러한 순차 자료구조 방식의 문제는 연결 자료구조 방식을 이용함으로써 해결 할 수 있다.
  
  연결 자료구조 방식의 단순 연결 리스트를 이용하여 스택을 구현하면 스택의 원소는 연결 리스트의 노드가 된다.
  스택에 원소를 삽입할 때마다 연결 리스트에 노드를 하나씩 연결한다. 그리고 스택 원소들 간의 순서는 연결 리스트 노드의 링크를 사용하여 표현한다.
  스택의 top을 표현하기 위해서 참조 변수 top을 사용한다. 
  
  스택의 초기 상태(공백 스택)는 참조변수 top을 null로 설정하여 표현한다. 
  공백 스택을 생성하고, 원소 A, B, C를 순서대로 삽입한 후에 원소 하나를 삭제하는 과정을 살펴보자.
  (1), 공백 스택 생성 : create(stack);
  (2), 원소 A 삽입 : push(stack, A);
  (3), 원소 B 삽입 : push(Stack, B);
  (4), 원소 C 삽입 : push(Stack, C);
  (5), 원소 삭제 : pop(stack);
  
●스택의 응용
  1, 역순 문자열 만들기
  스택의 LIFE 성질을 이용하여 문자열에 대한 역순 문자열을 간단히 만들 수 있다. 문자열을 처움부터 순서대로 스택에 삽입(push)한다.
  이제 스택에 있는 원소들을 공백 스택이 될 때까지 삭제하면서 반환된 문자를 나열하면 원래 문자열의 역순 문자열이 된다.  

  2, 시스템 스택
  "프로그램 간의 호출과 복귀"에 따른 수행 순서를 보면, 호출한 순서와 복귀하는 순서는 반대가 되어 
  나중(Last)에 호출된 함수가 가장 먼저(First) 실행을 완료하고 복귀한다.
  따라서 함수의 호출과 복귀 순서는 스택의 LIFO 구조를 응용하여 관리하는데, 이때 사용하는 스택을 시스템 스택(System Stack)이라 한다.
  
  (1), 주 프로그램인 main() 함수 실행 시작
  (2), F_1()함수 호출
  (3), F_1()함수를 실행 중에
  (4), F_2()함수 호출
  (5), F_2()함수를 실행
  (6), F_2()함수 실행을 마치고 호출 위치로 복귀
  (7), F_1()함수로 복귀(복귀주소:b)하여 나머지 부분 실행
  (8), F_1()함수 실행을 마치고 호출 위치로 복귀
  (9), main() 함수로 복귀(복귀주소:a)하여 나머지 부분을 실행하고 종료
  
  위의 프로그램 수행에 따른 시스템 스택의 변화를 살펴보자
  (1), 프로그램이 실행을 시작하여 main() 함수가 실행되면서 main() 함수와 관련된 정보를 스택 프레임에 담아 시스템 스택에 삽입한다.
  ==> push(System_stack, stack_Frame(main));  
  (2), main() 함수 실행 중에 F_1() 함수 호출을 만나면 함수 호출과 복귀에 필요한 정보를 스택 프레임에 담아
  시스템 스택에 삽입한다. 이때 스택 프레임에는 호출된 함수(F_1())의 수행이 끝나고 main() 함수로 복귀할 때 필요한 주소 a가 저장된다.
  ==> push(System_stack, stack_Frame(F_1));  
  (3), 호출된 함수인 F_1() 함수를 실행한다.
  (4), F_1() 함수 실행 중에 F_2() 함수 호출을 만나면 다시 함수 호출과 복귀에 필요한 정보를
  스택 프레임에 담아 시스템 스택에 삽입한다. 이때 스택 프레임에는 F_1() 함수로 복귀할 때 필요한 주소 b가 저장된다.
  ==> push(System_stack, stack_Frame(F_2));
  (5), 호출된 함수인 F_2()함수를 실행한다.
  (6), F_2() 함수 실행이 끝나면 F_2() 함수를 호출했던 예전 위치로 복귀하여 함수(F_1())의 실행을 계속해야 한다.
  그러려면 복귀할 주소 정보가 필요한데, 이런 정보들은 시스템 스택에 있으므로 시스템 스택의 top에 있는 스택 프레임을 pop하여 정보를 확인하고 복귀를 실행한다.
  ==> pop(System_stack);
  (7), F_1() 함수로 복귀하여 F_1() 함수의 나머지 부분을 실행한다.
  (8), F_1() 함수의 실행이 끝나면 이제 F_1() 함수를 호출했던 main() 함수의 예전 위치로 복귀하여 다시 실행을 계속해야 한다.
  그러려면 역시 복귀할 주소 등의 정보가 필요한데, 이런 정보들을 얻기 위해서 시스템 스택의 top에 있는 스택 프레임의 pop하고 복귀를 실행한다.
  ==> pop(System_stack);
  (9), main() 함수로 복귀하여 나머지 부분을 실행한다. 실행이 끝나면 다시 시스템 스택의 top에 있는 스택 프레임을 pop하고 복귀를 실행하는데,
  주 프로그램인 main() 함수는 복귀할 주소를 가지고 있지 않으므로 전체 프로그램의 수행이 완료된다. 정상적인 함수 호출과 복귀가 모두 완료되었으므로
  시스템 스택은 공백 스택이 된다.
  ==> pop(System_stack);
  
  3, 수식의 괄호 검사
  수식은 일반적으로 연산자(operator)와 피연산자(operand)로 구성되어 있으며, 왼쪽에서 오른쪽 순서로 처리한다.
  수식에 사용한 연산자의 우선순위가 다를 경우에는 우선순위가 높은 연산자를 먼저 처리하는데, 괄호를 사용하여 우선순위를 표현하기도 한다.
  이때 괄호는 일반괄호((,))와 중괄호({,}) 또는 대괄호([,])를 사용한다. 괄호는 왼쪽 괄호와 오른쪽 괄호가 반드시 쌍을 이루어야 하며,
  여러 개의 괄호가 중첩된 경우에는 가장 안쪽의 괄호를 먼저 처리한다.
  
  괄호가 포함된 수식에서 괄호의 쌍이 제대로 사용되었는지를 검사하기 위해서 스택을 사용 할 수 있다.
  수식을 읽으면서 왼쪽 괄호를 만나면 스택에 push하고, 오른쪽 괄호를 만나면 괄호면 괄호의 쌍이 맞는 것이고, 수식의 처리가 모두 끝났을 때
  스택이 공백 스택이 되면 왼쪽 괄호와 오른쪽 괄호의 개수가 맞는 것이다.  
  
  {(A+B)-3}*5+[{cos(x+y)+7}-1]*4 ==> 원본
  { (A + B) - 3 } * 5 + [ { cos(x + y) + 7} - 1 ] * 4
  (1), push(stack, '{' )
  (2), push(stack, '(' )  
  (3), pop(stack) ==> '('
  (4), pop(stack) ==> '{'
  (5), push(stack, '[')
  (6), push(stack, '{')
  (7), push(stack, '(')
  (8), pop(stack) ==> '('
  (9), pop(stack) ==> '{'
  (10), pop(stack) ==> '{'
  ==> 각 과정에서 처리할 오른쪽 괄호와 스택에서 pop한 원소가 같은 종류의 괄호이고, 수식 처리가 끝났을 때
  스택이 공백 스택이 되었으므로 위의 수식은 괄호가 올바르게 사용된 수식임을 확인할 수 있다.
  
  4, 수식의 후위 표기법 변환
  연산자와 피연산자로 구성된 수식을 표기하는 방법은 연산자의 위치에 따라 다음의 세 가지 표기법이 있다.
  (1), 전위 표기법(Prefix Notation)
  연산자를 앞에 표기하고 그다음에 피연산자를 표기하는 방법 ex) +AB
  (2), 중위 표기법(Infix Notation)
  연산자를 피연산자의 가운데에 표기하는 방법 ex) A+B
  (3), 후위 표기법(Postfix Notation)
  연산자를 피연산자 뒤에 표기하는 방법 ex) AB+
  
  일반적인 중위 표기법의 수식을 전위 표기법으로 변환하는 예를 살펴보자. 
  수식 A*B-C/D를 다음의 방법을 사용하여 전위 표기법으로 변환해보자.
  (1), 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다.
  (2), 각 연산자를 그에 대응하는 왼쪽 괄호의 앞으로 이동시킨다.
  (3), 괄호를 제거한다.
  
  다음은 중위 표기법의 수식을 후위 표기법으로 변환하는 방법이다. 같은 수식 A*B-C/D를 이번에는 후위 표기법으로 변환해보자.
  (1), 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다.
  (2), 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동시킨다.
  (3), 괄호를 제거한다.
  
  다음은 컴퓨터 내부에서 중위 표기법을 후위 표기법으로 바꾸는 과정이다.
  스택을 이용하여 수식 A*B-C/D를 후위 표기식으로 변환해보자.
  (1), 왼쪽 괄호를 만나면 무시하고 다음 문자를 읽는다.
  (2), 피연산자를 만나면 출력한다.
  (3), 연산자를 만나면 스택에 삽입한다.
  (4), 오른쪽 괄호를 만나면 스택을 pop하여 출력한다.
  (5), 수식이 끝나면 스택이 공백이 될 때까지 pop하여 출력한다.
  
  5, 후위 표기 수식의 연산
  컴퓨터 내부에서 후위 표기법의 수식을 연산할 때에도 스택을 사용할 수 있다. 스택을 사용하여 수식을 계산하기 위한 처리 방법을 알아보자.
  (1), 피연산자를 만나면 스택에 삽입한다.
  (2), 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산 결과를 다시 스택에 삽입한다.
  (3), 수식이 끝나면, 마지막으로 스택을 pop하여 출력한다.
  
  
*/